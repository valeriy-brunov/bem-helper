## Реализация БЭМ в cakePHP

[Быстрый старт.](#bst)

[Создание блоков.](#sb)

[Создание элементов.](#sa)

[Система меток.](#metka)

[Добавление модификаторов, миксов, атрибутов и контента к блокам и элементам. Изменение типа тега на лету.](#yprblockelem)

[Вывод повторяющихся блоков и элементов.](#repeat-block-element)

[Система видов. Использование помошника Bem с AJAX.](#ajax)

[Создание виртуальных блоков.](#virt-block)

[Вспомогательные переменные.](#auxiliary-variables)

[Особенности вёрстки при использовании БЭМ-хэлпер](#bem-helper)

[Разделение блоков в структуре элементов cakePHP.](#razdelenie-blockov)

<a id="bst"></a>
### Быстрый старт.

Для реализации методологии вёрстки БЭМ в cakePHP используется помошник (helper) `Bem`.

Чтобы создать новый блок, необходимо создать файл `элемента cakePHP`, поместив туда нижеприведённый код.
Имя файла `элемента cakePHP` будет именем блока по методологии БЭМ.

```php
<?php
/**
 * Имя файла, в который будет помещён этот код - "forms.php". Это имя и будет
 * именем блока по методолошии БЭМ.
 *
 * ../templates/element/forms.php
 */
?>

<?php
	$bem = $this->Bem;
	$forms = $conf['forms'];
?>

<?php echo
	$forms->blockDiv([
		'Это внутреннее содержимое блока',
		'И это тоже контент блока',
	]);
?>
```

Чтобы отобразить этот блок (блок "forms"), необходимо в файл вида добавить следующий код:

```php
<?php echo
	$this->Bem->block('forms');
?>
```

Запуск данного кода приведёт к созданию помошником html-кода блока.

```html
<div class="forms">Это внутреннее содержимое блокаИ это тоже контент блока</div>
```

<a id="sb"></a>
### Создание блоков

Создание блока начинается с создания файла `элемента cakePHP`, имя которого должно совпадать с
именем блока. В начале любого файла блока необходимо поместить следующий код:

```php
<?php
	$bem = $this->Bem;
	$имя_блока = $conf['имя_блока'];
?>
```

Первая строка вышеприведённого кода получает доступ к экземпляру помошника `Bem`. Используя 
экземпляр `$bem` можно, например, вкладывать в текущий блок другие блоки.

Вторая строка - экземпляр текущего блока. Элементы текущего блока должны использовать этот
экземпляр.

Имя метода блока представляет горбатую запись, где первая часть указывает на блок (block).
Вторая часть сообщает о теге, c помощью которого реализуется блок. Например, для блока `forms`:

```php
// Блок <DIV></DIV>
$forms->blockDiv();

// Блок <SPAN></SPAN>
$forms->blockSpan();

// Блок <A href=""></A>
$forms->blockA();

// Блок <form...>...</form>
$forms->blockForm();

// ...  и т.д.
```

Содержимое блока указывется внутри квадратных скобок в виде массива. Метод, формирующий
блок, склеит массив в одну строку.

```php
$forms->blockТЭГ([ Содержимое или контент ], метка_блока );
```

Например, поместим во внутрь блока несколько строк текста:

```php
<?php echo
    $forms->blockSpan([
        'Первая строка.',
        'Вторая строка.',
    ]);
?>
```

или несколько элементов и текст:

```php
<?php echo
    $forms->blockDiv([
        $forms->elemDiv('item'),
		'Текст текст текст',
		$forms->elemDiv('text'),
    ]);
?>
```

Метку блока указывать не обязателно (см. раздел [Система меток](#metka)).

<a id="sa"></a>
### Создание элементов.

Элемент - внутренняя реализация блока. Элемент создаётся из экземпляра блока.

Имя метода элемента представляет собой горбатую запись, где первая часть указывает на элемент (elem).
Вторая часть сообщает о теге, c помощью которого реализуется блок. Например, для элементов блока `forms`:

```php
// Элемент <DIV></DIV>
$forms->elemDiv();

// Элемент <SPAN></SPAN>
$forms->elemSpan();

// Элемент <A href=""></A>
$forms->elemA();

// ...  и т.д. для других тегов.
```

Содержимое элемента указывется внутри квадратных скобок в виде массива. Метод, формирующий
элемент, склеит массив в одну строку.

```php
$forms->elemТЭГ('имя_элемента', [ Содержимое или контент ], метка_элемента);
```

Метку элемента указывать не обязателно (см. раздел [Система меток](#metka)).

Например, элемент вложенный в элемент.

```php
...
$forms->elemDiv('item', [
	$forms->elemDiv('my-text'),
]),
...
```

<a id="metka"></a>
### Создание меток.

Для того, чтобы идентифицировать элементы и блоки с одинаковыми именами используют метки.

Метка, если возникает такая необходимость, указывается в блоке или элементе после указания
содержимого или контента. Для этого используется следующая запись:

```php
$bem->id( имя_метки ),
```

Имя метки может быть, как числом, так и буквой или целым словом, например:

```php
<?php
	...
	$bem->id(1), // Метка 1.
	$bem->id('metka'), // Метка с именем "metka".
	...
?>
```

Примеры указания меток в блоке или элементе:

```php
<?php
	...
	$forms->blockDiv([], $bem->id(1)),
	$forms->elemDiv('text', [], $bem->id('text-elem')),
	...
?>
```

Для указания меток можно использовать, как текущий экземпляр блока, так и новый экземпляр,
содержащийся в переменной `$bem`.

<a id="yprblockelem"></a>
### Добавление модификаторов, миксов, атрибутов и контента к блокам и элементам. Изменение типа тега на лету.

Для отображения блока используется следующая запись:

```php
<?php echo
	$this->Bem->block('forms', ['conf' => [
		'mod' => [], // Перечень модификаторов.
		'mix' => [], // Перечень миксов.
		'content' => [], // Контент или содержимое.
		'attr' => [], // Перечень атрибутов.
	]);
?>
```

Массив `conf` содержит в себе применительно для данного блока, а также для других вложенных в него блоков
и элементов модификаторы, миксы, контент и атрибуты.

Для добавления модификаторов:

```php
	...
	'mod' => [
		'имя-блока или имя-элемента' => [
			массив-перечень модификаторов
		],
	],
	...
```

Имя блока пишется полностью, допускается указание имени блока через дифис. Имя элемента указывается через двойное
подчеркивание. Имя модификатора пишется кратко - начинается с одинарного подчёркивания. Например:

```php
<?php
	...
	'mod' => [
		'forms' => [ // Для блока "forms".
			'_display_hide', // Модификатор для блока 'forms'.
		],
		'forms__item' => [ // Для элемента "forms__item".
			'_display_show', // Модификатор для элемента 'forms__item'.
		],
	],
	...
?>
```

Правила для указания модификаторов также подходят для указания миксов, за исключением того, что первым в перечне
миксов должно идти имя блока-микса, а затем, при необходимости, указывать перечень модификаторов, относящихся к
блоку-миксу.

```php
<?php
	...
	'mix' => [
		'forms' => [
			'panel',         // Блок "panel" и относящийся к нему модификатор "_display_hide".
			'_display_hide',
			'my-block',      // Блок "my-block" и относящийся к нему модификатор "_display_show".
			'_display_show',
		],
	],
	...
?>
```

Независимо от того, какой контент отображает блок, его можно изменить или добавить новый, даже если этот контент
формируется другим блоком. Например:

```php
<?php
	...
	'content' => [
		'forms' => 'Новый контент заменит содержимое блока!', // Блок "forms" с новым содержимым.
	],
	...
?>
```

Можно добавлять массив контента, который затем склеится в одну строку:

```php
<?php
	...
	'content' => [
		'forms' => [
			'Новый контент заменит содержимое блока!',
			'Это тоже контент!',
			'Все строчки массива склеятся в одну строку.',
		],
	],
	...
?>
```

Также контент можно изменять или добавлять используя метки:

```php
<?php
	...
	'content' => [
		'forms' => 'Новый контент заменит содержимое блока!', // Блок "forms" с новым содержимым.
		'upload-file' => [
			'Новое!', // Данный контент будет добавлен ко всем блокам "upload-file".
			'[2]' => 'Строка!', // Контент будет заменён у блока "upload-file" с меткой "[2]".
			'[3]' => ['Ещё строка!'], // Контент будет заменён у блока "upload-file" с меткой "[3]".
			'10{1}' => [     // Метка для блока "upload-file". Данный контент будет добавлен только к блоку "upload-file"
				'Вот так!', // с меткой "[10]".
				'Ещё!',
			],
		],
	],
	...
?>
```

При указании метки для вставки контента содержимое может быть как массивом, так и строкой.

```php
<?php
	...
	'content' => [
		'upload-file' => [
			'10{1}' => ['Вот так!'], // Контент будет применён к блоку "upload-file" с меткой "10{1}".
			'Новое!', // Данный контент будет добавлен ко всем блокам "upload-file".
		],
		'upload-file__items' => [
			'[1]' => ['Метка для элемента!'],
		],
	],
	...
?>
```

В блоках и элементах, помимо атрибута "class", часто возникает необходимость указания дополнительных атрибутов.
Реализуется это следующим образом:

```php
<?php
	...
	'attr' => [
		'forms' => [ // Блок "forms".
			'data-bem' => '{ "my-block":{} }', // Атрибут и его значение.
			'url' => '/cccc.html', // Атрибут и его значение.
		],
	],
	...
?>
```

При добавлении атрибута `'data-bem'` к блоку или элементу, класс `'i-bem'` добавляется автоматически и не требует от пользователя
каких-либо дополнительных действий.

Для блоков и элементов, имеющих одинаковые имена, необходимо использовать метки. Метка указывается на том же уровне,
что и модификаторы, миксы, контент и атрибуты. Для записи метки используют упрощённое регулярное выражение.

Перечень наиболее часто используемых меток:

    [1] - точное значение;
    [0-2] - диапазон значений;
    [^1-3] - кроме диапазона значений;
    (1|3) - либо 1, либо 3;
    10{1} - точное значение 10.

Для меток, состоящих из более одной цифры, необходимо указывать количество повторений значения метки, например: `10{1}`.

Пример использования меток в коде:

```php
<?php
	...
	'mod' => [ // Перечень модификаторов.
		'forms__item' => [ // Элемент "forms__item".
			'_display_hide', // Модификатор для всех элементов "forms__item".
			'[1]' => [ // Метка для элемента "forms__item".
				'_size_big', // Перечень модификаторов для элементов "forms__item" с меткой '[1]'.
				'_description_vertical',
			],
			'[2]' => '_description_horizontal',
			'[3]' => ['_size_small'],
		],
	],
	...
	'mix' => [
		'forms' => [
			'panel',
			'_display_hide',
		],
		'forms__item' => [
			'button',
			'[1]' => [
				'first',
				'_display_hide',
			],
			'[2]' => 'my-panel',
		],
	...
	'content' => [
		'forms' => 'Новый контент.',
		'upload-file' => [
			'[10]' => [
				'Вот так!',
				'Ещё!',
			],
			'Что-то новенькое!',
		],
		'forms__item' => [
			'Это снова контент.',
			'[1]' => ['  А вот и я!  '],
		],
	],
	...
	'attr' => [
		'forms' => [
			'data-bem' => '{ "my-block":{} }',
			'url' => '/my-syte.html',
		],
		'forms__item' => [
			'data-bem' => '{ "my-block2":{} }',
			'[1]' => [
				'data-fid' => '16',
			],
		],
		'upload-file' => [
			'data-bem' => '{ "my-block3":{} }',
		],
	],
	...
?>
```

Часто возникает необходимость заменить один тип тега на другой тип. Например, внешний слой блока
формируется тегом "div" и необходимо его заменить типом "span". Сделать это можно, в массиве `'conf'`:

```php
<?php
	...
	'tag' => [ // Массив с заменой тегов.
		'img' => 'div', // Заменить в блоке 'img' тип тега на 'div'.
		'img__item' => 'p',
		'img__img' => [
			'[1]' => 'div', // Заменить в элементе с меткой '[1]' тип тега на 'p'.
			'span',					// У всех остальных элементов тип тега изменить на 'div'.
		],
	]]
	...
?>
```

<a id="repeat-block-element"></a>
### Вывод повторяющихся блоков и элементов

Для вывода повторяющихся блоков и элементов используют анонимные функции (лямбда) функции.

```php
<?php echo
	$forms->blockForm([
		$list = function() use ($bem, $conf) {
			$str = '';
			for ( $i=1; $i<=3; $i++ ) {
				$str.= $bem->block('upload-file', ['conf' => $conf], $bem->id($i) ); // Метка задаётся динамически.
			}
			return $str;
		}, $list(), // Функция для отображения анонимной функции.
	]);
?>
```

В цикле элементу или блоку необходимо задать метку для идентификации блока или элемента. В качестве значения метки
не обязательно использовать цифры, можно использовать буквенно-цифровое значение.

```php
<?php
	...
	$str.= $bem->block('upload-file', ['conf' => $conf], $bem->id('metka' . $i) )
	...
?>
```

Чтобы повторить элемент опредёлённое количество раз для блока "forms":

```php
<?php echo
	$forms->blockForm([
		$a = function() use ($forms, $conf) {
			$str = '';
			for ( $i=4; $i<=6; $i++ ) {
				$str.= $forms->elemSpan('ttt', ['Угу!'], $forms->id($i) );
			}
			return $str;
		},$a(),
	]);
?>
```

<a id="ajax"></a>
### Система видов. Использование помошника Bem с AJAX.

Помошник `Bem` позволяет создавать views-виды и использовать их для показа определённых частей
блока. Такой способ удобно использовать при AJAX-вызовах, когда необходимо вернуть для показа
только часть блока. Для этого в массиве `conf` следует указать перечень views-видов:

```php
<?php
	...
	'views' => [ // Перечень Views-видов.
		'first' => [ // Название Views-вида 'first'.
			'forms', // Показать оболочку блока 'forms'.
			'forms__item', // Показать элемент 'forms__item' со всем содержимым.
		],
		'two' => [ // Views-вид 'two'.
			'forms', // Показать только блок 'forms'.
		],
	],
	...
?>
```

Вид, который необходимо показать для текущего блока, задаётся в массиве `conf`:

```php
<?php
	...
	'show' => 'two', // Показать AJAX-вид 'two'.
	...
?>
```

Обычно вид в массиве `conf` явно не указывается. Вместо views-вида указывают переменную,
содержащую название views-вида. Её значение, обычно, задаётся в контроллёре.

```php
<?php
	...
	'show' => $show ?? null,
	...
?>
```

Приведём объединённый вышеприведённый код ajax-видов:

```php
<?php
	...
	'views' => [ // Перечень AJAX-видов.
		'first' => [
			'forms',
			'forms__item',
		],
		'two' => [
			'forms',
		],
	],
	'show' => $show ?? null,
	...
?>
```

Важно:

    У блоков возможно отключить только оболочку, содержимое всё равно будет показано.
    Элементы скрывается вместе с содержимым.

Блоки и элементы можно задавать при помощи меток, обернув имя блока или элемента в массив: тогда
имя блока или элемента будет ключом массива, а значение массива - перечень меток.

```php
<?php
	...
	'views' => [
		'first' => ['forms', ['upload-file' => ['[2]', '[3]'] ], 'forms__item' ],
		'two' => ['forms'],
	],
	'show' => 'first',
	...
?>
```

<a id="virt-block"></a>
### Создание виртуальных блоков.



<a id="auxiliary-variables"></a>
### Вспомогательные переменные.

В случае, когда блоку для работы необходимы дополнительные переменные их можно передать
через вспомогательные переменные.

Вспомогательные переменные задаются в массиве `conf` с ключом `var`, далее идёт имя вспомогательной
переменной и её значение.

```php
<?php
	...
	'mod' => [
		'forms__item' => [ ... ],
	],
	...
	'var' => [
			'list_repeat_start' => 1,
			'list_repeat_end' => 'Это значение вспомогательной переменной!',
	],
	...
?>
```

Для получения блоком значений заданных вспомогательными переменными, необходимо обратиться из текущего
экземпляра блока к методу `var`, с указанием имени вспомогательной переменной, которую необходимо получить.

```php
<?php // Блок "List".
	$bem = $this->Bem;
	$list = $conf['list']; // Текущий экземпляр блока "List".
?>

<?php echo
	$list->var('myvar'); // Значение вспомогательной переменной "myvar".
?>
```

Очень часто вспомогательные переменные используют для указанию циклу "for" с какого значения он должен начинаться
и каким значением заканчиваться. Покажем это на примере:

```php
<?php
	$bem = $this->Bem;
	$list = $conf['list'];
?>

<?php echo
	$list->blockUl([
		$l = function() use ($list, $conf) {
			$str = '';
			for ( $i=$list->var('list_repeat_start'); $i<=$list->var('list_repeat_end'); $i++ ) {
				$str.= $list->elemLi('item', ['conf' => $conf], $list->id($i) );
			}
			return $str;
		}, $l(),
	]);
?>
```

<a id="bem-helper"></a>
### Особенности вёрстки при использовании БЭМ-хэлпер.

Система БЭМ-хэлпер подразумевает возможность многократного использования одних и тех же блоков. Причём
один блок может включать в себя многократные вложения других блоков. В тех случаях, когда при загрузке
страницы алгоритм выбирает через контроллёр, какой вид показывать, скрытые блоки, не входящие в данный
вид, все равно произведут действие и, возможно, не получив необходимые данные для своего формирования,
сработают с ошибкой. Чтобы избежать такой неприятной ситуации, необходимо чтобы блоки, которые являются
вложенными, срабатывали не до основного блока, в который они вложены, а основной блок управлял их
формированием и, если необходимо, при запросе определённого вида, не включал их в работу.

    Те блоки, которые будут вложены в основной блок, должны быть обёрнуты в анонимную (лямбда) функцию.
    Эта функция может находиться в любом месте вида.

```php
<?php
	// Анонимная (лямбда) функция.
  $online = function() use( $bem = $this->Bem, $list_repeat_start, $list_repeat_end ) {
		return $bem->block('list', ['conf' => [
			'mix' => [
				'list__item' => [
					'text',
					'_style_normal',
					'_size_tiny',
				],
			],
			'content' => [
				'list__item' => '<i class="icons icons_smart icons_size_large icons_style_normal"></i> Онлайн',
			],
			'var' => [
				'list_repeat_start' => $list_repeat_start,
				'list_repeat_end' => $list_repeat_end,
			],
		]]);
	}
?>
```

Вложенные блоки вставляются в основной блок путём присвоения в массиве настроек блока `conf` в секции `content` переменной,
содержащей html-вёрстку блока. В зависимости от вида блока (имя блока указывается в `show`, вложенный блок
может как отображаться, так и скрываться в основном блоке. Чтобы привязать вложенный блок к виду блока,
при вызове которого вложенный блок необходимо показать, используют условие, как показано в примере ниже:

```php
<?php echo
		$this->Bem->block('img', ['conf' => [
			'content' => [
				'img__delete' => '<i class="icons icons_close icons_size_normal icons_style_normal"></i>',
				// Условие показа вложенного блока 'online'.
				'img__online' => ( $show_img == 'first' ? $online() : '' ),// Для вида 'first' вызвать анонимную функцию.
			],
			'attr' => [
				'img' => [
					'style' => 'background-image: url(' . $this->Url->build( $url, ['fullBase' => true] ) . ')',
				],
			],
			'views' => [
		 		'first' => ['img', 'img__view', 'img__online' ],
		 		'two' => ['img', 'img__delete'],
		 	],
	 		'show' => $show_img ?? null,// Переменная $show_img задаётся из контроллёра.
		]]);
	?>
```

<a id="razdelenie-blockov"></a>
### Разделение блоков в структуре элементов cakePHP.

Использование БЭМ-хэлпер позволяет получить код блоков "чистыми". Это значит, что изменения отображения блоков
производят извне, не затрагивая вёрстку блоков. Настройку блоков производят из видов: добавляют модификаторы, 
миксы, контент и атрибуты.

Массив настроек блока может быть очень длинным. А так как вид может включать в себя не один десяток блоков,
включая вложенные блоки, которые необходимо тоже настраивать, необходимо отделить "чистые" блоки от блоков использующихся
в видах и требующих настройки.

Лучшим решением будет создания каталога `'views'` в `../templates/element/` где необходимо располагать блоки,
которые будут иметь настройки для использования в конкретном виде. Загрузку блоков из каталога `'views'` необходимо
производить с помощью стандартных элементов cakePHP.

```php
<?php
/**
 * Элемент cakePHP 'listing-photos.php'.
 * Располагается в '../templates/element/'.
 */
?>
<?php
	// Анонимная (лямбда) функция.
	$img = function() use( $url ) {
		return $this->Bem->block('img', ['conf' => [
			'mod' => [
				'img__delete' => [
					'_form_round',
					'_discription_in-corner',
				],
			],
			...
			'views' => [
				 'first' => ['img', 'img__delete' ],
			],
			 'show' => 'first',
		]]);
	}
?>

<?php echo // Блок 'list', внурь которого вставляется блок 'img'.
	$this->Bem->block('list', ['conf' => [
		'mod' => [
			'list' => [
				'_discription_horizontal',
			],
			'list__item' => [
				'[2]' => ['_theme_indicator'],
			],
		],
		'content' => [
			'list__item' => [
				'[1]' => $img(),
				'[2]' => $indicator(),
			],
		],
		'var' => [
			'list_repeat_start' => 1,
			'list_repeat_end' => 2,
		],
	]]);
?>
```

Для вызова элемента cakePHP 'listing-photos.php' необходимо в виде написать:

```php
<?php echo $this->element('views/listing-photos') ?>
```

Можно использовать краткую запись:

```php
<?= $this->element('views/listing-photos') ?>
```

"Чистые" блоки располагаются в крневом каталоге '../templates/element/'.

Следует обратить внимание на следующее:

    Если передача данных через анонимную функцию не требуется, то указывать пустой `use()` не нужно,
    иначе будет вызвана ошибка.

    Нет необходимости передавать значения переменных через элемент cakePHP, в любом случае, значения
    переменных, указанных в контроллёре через `$this->set()` проникнут в любой элемент вида.

